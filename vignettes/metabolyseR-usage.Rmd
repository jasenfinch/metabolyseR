---
title: "metabolyseR"
author: "Jasen Finch"
date: "July 2017"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{metabolyseR-usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r libraryLoad,echo=FALSE}
suppressPackageStartupMessages(library(metabolyseR))
```

## Introduction

Extracting biological information  related to experimental treatments from metabolomics data involves a number of steps; data pre-treatment, assessing the extent discrimination between treatment classes and identifying explanatory features responsible for this discrimination.
The *metabolyseR* package provides a suite of methods that encompass these aspects of metabolomics data analysis.
Below shows the four analysis elements in that make up metabolyseR.

```{r metabolyseRDiagram,echo=FALSE,fig.width=6}
  DiagrammeR::grViz(readr::read_file('figures/metabolyseR.gv'))
```

This document will provide a tutorial on the basic usage of the package, followed by more detailed discussion of each of the analysis elements.
Lastly, there will be discussion of the tools for the visualisation of the results from these data as well as the integration of metabolyseR into wider metabolomics workflows.
This allows more bespoke analyses to be performed based on the particular metabolomics technique being used.

*metabolyseR* has been written to be as generic and versatile as possible to allow analyses to be tailored to the particular needs of the metabolomics techniques being used.
With this in mind, it's application doesn't need to be restricted only to metabolomics data.
These analysis elements could, for example, also be suitable for data such as gene expression data where replication allows.

The examples shown here use the `abr1` dataset from the *[FIEmspro](https://github.com/wilsontom/FIEmspro)* package (`?FIEmspro::abr1`).

## Basic Usage

*metabolyseR* has three main functions for performing analyses:

* `analysisParameters` - allows the selection of analysis parameters.
* `metabolyse` - input data and info to analyse using the selected parameters.
* `reAnalysis` - re-analyse data previously analysed using `metabolyse` based on newly selected parameters.

### Parameter Selection
Parameter selection is the fundamental aspect of using *metabolyseR* and will be the most modified as it dictates how the analyses will be performed.
`analysisParameters` returns an object of class `AnalysisParameters` containing the relevent parameters of the selected analysis elements.
For example, the code below will return default parameters for all the *metabolyseR* analysis elements.

```{r parametersExample,eval=FALSE}
parameters <- analysisParameters()
parameters
```

To retrieve parameters for a subset of elements the following can be run, which will return parameters for only the `preTreat` and   `classification` elements. 

```{r parametersElementSubset,eval=FALSE}
parameters <- analysisParameters('preTreat','classification')
parameters
```

The parameters for the individual analyis elements in the `AnalysisParameters` object can be accessed using the `@` extraction operator.
The following code illustrates how to modify the pre-treatment parameters to allow variable occupancy filtering and total ion count normalisation.

```{r parametersSetExample,eval=FALSE}
parameters@preTreat <- list(
    occupancyFilter = list(maximum = list()),
    transform = list(TICnorm = list())
)
parameters
```

Discussion of parameters particular to the individual analysis elements can be found in the relevant analysis element sections.

### Analysis

Executing analyses is simple using the `metabolyse` function with specification of the data to use, the sample meta-information (info) and the analysis parameters.
This is shown by the following code.

```{r metabolyseExample,eval=FALSE}
data(abr1,package = 'FIEmspro')
analysis <- metabolyse(abr1$neg,abr1$fact,parameters) 
analysis
```

The data and info can be either `tibble` or `data.frame` structures and the parameters should be an S4 object of class `AnalysisParameters`.
The order of the rows of the info table should agree with those in the data table.

`metabolyse` will be output and S4 object of class `Analysis`.
Data and analysis results can be extracted from this object using the following functions:

* `rawData` - raw data and info.
* `preTreatedData` - pre-treated data and info.
* `classificationResults` - classification results.
* `featureSelectionResults` - feature selection results.
* `correlationResults` - correlation results.

If data pre-treatment has not been performed prior to classification or feature selection, the raw data will automatically be used.
The date and time of each of analyis of each of the elements is also stored and can is displayed when the object is printed.

### Re-Analysis

There are likely to be occasions where analyses need to be re-analysed using a new set of parameters. 
`reAnalyse` can be used for this.
It simply requires the specification of the `Analysis` object and parameters for the re-analysis as shown below.

```{r reAnalyseExample,eval=FALSE}
parameters <- analysisParameters('featureSelection')
analysis <- reAnalyse(analysis,parameters)
analysis
```

## Pre-Treatment

Data pre-treatment is the most faceted aspect of the analysis elements in *metabolyseR*.
It itself is made up of a number of elements, which themselves are made up of methods.
The pre-treatment elements can be seen below.

```{r preTreatmentDiagram,echo=FALSE,fig.width=6}
  DiagrammeR::grViz(readr::read_file('figures/preTreat.gv'))
```

The parameter selection for the pre-treatment elements will firstly be discussed, with more indepth discussion on the methods of the individual elements to follow. 

### Parameter Selection

The default pre-treatment parameters can be seen below.

```{r preTreatDefaults}
analysisParameters('preTreat')
```

This pre-treatment analysis is made up of three elements that include variable filtering based on QC samples, missing data imputation and data transfromation (QC, impute, transform).
Each of these elements is made up of varying numbers of methods, with each method having its own arguments.
The order in which these elements and their methods is displayed is the order in which their execution upon the data will take place.
This allow particular data pre-treatment routines to be specified depending on what is required for the particular data.

Pre-treatment routines can be customised by altering the `preTreat` slot within the `AnalysisParameters` object as shown below.

```{r preTreatParameterExample}
data("abr1",package = 'FIEmspro')
parameters <- analysisParameters('preTreat')
parameters@preTreat <- list(
    remove = list(
      class = list(
        cls = 'class',
        classes = unique(abr1$fact$class)[!(unique(abr1$fact$class) %in% c(1,2))])),
    occupancyFilter = list(
      maximum = list()),
    transform = list(
      TICnorm = list())
)
parameters
```

This routine will firstly remove a number of classes, filter the variables based on class occupancy and then transfrom the data using a total ion count normalisation.

The pre-treatment routines are specified as a hierarchy of lists within lists.
Firstly the pre-treatment elements should be specified within a list with the particular element methods specified as lists within these.
The method arguments are then declared within these lists.
Empty lists for methods can be specified to use the default arguments; however, element lists should not be empty. 

The pre-treatment routine can then be executed using the following.
```{r preTreatExample}
analysis <- metabolyse(abr1$neg,abr1$fact,parameters)
analysis
```

### Remove Samples and Classes
```{r removeMethodsTable,echo=FALSE,results='asis'}
desc <- metabolyseR:::removeMethods(description = T)
args <- lapply(desc,function(x){return(x$arguments)})
args <- lapply(args,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
args <- lapply(args,function(x){apply(x,1,function(y){paste(y,collapse = ' - ')})})
if (T %in% (sapply(args,length) > 1)) {
  args[sapply(args,length) > 1] <- lapply(args[sapply(args,length) > 1],function(x){paste(x,collapse = '; ')})
}
args <- unlist(args)
desc <- unlist(lapply(desc,function(x){return(x$description)}))
meth <- names(metabolyseR:::removeMethods())
defaults <- lapply(metabolyseR:::removeMethods(),formals)
defaults <- lapply(defaults,function(x){x$dat <- NULL;return(x)})
defaults <- lapply(defaults,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
defaults <- lapply(defaults,function(x){apply(x,1,function(y){paste(y,collapse = ' = ')})})
if (T %in% (sapply(defaults,length) > 1)) {
  defaults[sapply(defaults,length) > 1] <- lapply(defaults[sapply(defaults,length) > 1],function(x){paste(x,collapse = '; ')})
}
defaults <- unlist(defaults)
tab <- tibble::tibble(Method = meth, Description = desc, Arguments = args, Defaults = defaults)

knitr::kable(tab)
```

### Filter Variables based on occupancy
```{r occupancyMethodsTable,echo=FALSE,results='asis'}
desc <- metabolyseR:::occupancyMethods(description = T)
args <- lapply(desc,function(x){return(x$arguments)})
args <- lapply(args,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
args <- lapply(args,function(x){apply(x,1,function(y){paste(y,collapse = ' - ')})})
if (T %in% (sapply(args,length) > 1)) {
  args[sapply(args,length) > 1] <- lapply(args[sapply(args,length) > 1],function(x){paste(x,collapse = '; ')})
}
args <- unlist(args)
desc <- unlist(lapply(desc,function(x){return(x$description)}))
meth <- names(metabolyseR:::occupancyMethods())
defaults <- lapply(metabolyseR:::occupancyMethods(),formals)
defaults <- lapply(defaults,function(x){x$dat <- NULL;return(x)})
defaults <- lapply(defaults,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
defaults <- lapply(defaults,function(x){apply(x,1,function(y){paste(y,collapse = ' = ')})})
if (T %in% (sapply(defaults,length) > 1)) {
  defaults[sapply(defaults,length) > 1] <- lapply(defaults[sapply(defaults,length) > 1],function(x){paste(x,collapse = '; ')})
}
defaults <- unlist(defaults)
tab <- tibble::tibble(Method = meth, Description = desc, Arguments = args, Defaults = defaults)

knitr::kable(tab)
```

### Filter Variables based on QC samples
```{r QCMethodsTable,echo=FALSE,results='asis'}
desc <- metabolyseR:::QCMethods(description = T)
args <- lapply(desc,function(x){return(x$arguments)})
args <- lapply(args,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
args <- lapply(args,function(x){apply(x,1,function(y){paste(y,collapse = ' - ')})})
if (T %in% (sapply(args,length) > 1)) {
  args[sapply(args,length) > 1] <- lapply(args[sapply(args,length) > 1],function(x){paste(x,collapse = '; ')})
}
args <- unlist(args)
desc <- unlist(lapply(desc,function(x){return(x$description)}))
meth <- names(metabolyseR:::QCMethods())
defaults <- lapply(metabolyseR:::QCMethods(),formals)
defaults <- lapply(defaults,function(x){x$dat <- NULL;return(x)})
defaults <- lapply(defaults,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
defaults <- lapply(defaults,function(x){apply(x,1,function(y){paste(y,collapse = ' = ')})})
if (T %in% (sapply(defaults,length) > 1)) {
  defaults[sapply(defaults,length) > 1] <- lapply(defaults[sapply(defaults,length) > 1],function(x){paste(x,collapse = '; ')})
}
defaults <- unlist(defaults)
tab <- tibble::tibble(Method = meth, Description = desc, Arguments = args, Defaults = defaults)

knitr::kable(tab)
```

### Impute missing data
```{r imputeMethodsTable,echo=FALSE,results='asis'}
desc <- metabolyseR:::imputeMethods(description = T)
args <- lapply(desc,function(x){return(x$arguments)})
args <- lapply(args,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
args <- lapply(args,function(x){apply(x,1,function(y){paste(y,collapse = ' - ')})})
if (T %in% (sapply(args,length) > 1)) {
  args[sapply(args,length) > 1] <- lapply(args[sapply(args,length) > 1],function(x){paste(x,collapse = '; ')})
}
args <- unlist(args)
desc <- unlist(lapply(desc,function(x){return(x$description)}))
meth <- names(metabolyseR:::imputeMethods())
defaults <- lapply(metabolyseR:::imputeMethods(),formals)
defaults <- lapply(defaults,function(x){x$dat <- NULL;return(x)})
defaults <- lapply(defaults,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
defaults <- lapply(defaults,function(x){apply(x,1,function(y){paste(y,collapse = ' = ')})})
if (T %in% (sapply(defaults,length) > 1)) {
  defaults[sapply(defaults,length) > 1] <- lapply(defaults[sapply(defaults,length) > 1],function(x){paste(x,collapse = '; ')})
}
defaults <- unlist(defaults)
tab <- tibble::tibble(Method = meth, Description = desc, Arguments = args, Defaults = defaults)

knitr::kable(tab)
```

### Transform the data
```{r transformMethods,echo=FALSE,results='asis'}
desc <- metabolyseR:::transformMethods(description = T)
args <- lapply(desc,function(x){return(x$arguments)})
args <- lapply(args,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
args <- lapply(args,function(x){apply(x,1,function(y){paste(y,collapse = ' - ')})})
if (T %in% (sapply(args,length) > 1)) {
  args[sapply(args,length) > 1] <- lapply(args[sapply(args,length) > 1],function(x){paste(x,collapse = '; ')})
}
args <- unlist(args)
if (T %in% sapply(args,function(x){grepl("''",x)})) {
  args[sapply(args,function(x){grepl("''",x)})] <- lapply(args[sapply(args,function(x){grepl("''",x)})],function(x){''})
}
desc <- unlist(lapply(desc,function(x){return(x$description)}))
meth <- names(metabolyseR:::transformMethods())
defaults <- lapply(metabolyseR:::transformMethods(),formals)
defaults <- lapply(defaults,function(x){x$dat <- NULL;return(x)})
if (T %in% sapply(defaults,is.null)) {
  defaults[sapply(defaults,is.null)] <- lapply(defaults[sapply(defaults,is.null)],function(x){c(`''` = '')})
}
defaults <- lapply(defaults,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
defaults <- lapply(defaults,function(x){apply(x,1,function(y){paste(y,collapse = ' = ')})})

if (T %in% sapply(defaults,function(x){grepl("''",x)})) {
  defaults[sapply(defaults,function(x){grepl("''",x)})] <- lapply(defaults[sapply(defaults,function(x){grepl("''",x)})],function(x){''})
}

if (T %in% (sapply(defaults,length) > 1)) {
  defaults[sapply(defaults,length) > 1] <- lapply(defaults[sapply(defaults,length) > 1],function(x){paste(x,collapse = '; ')})
}
defaults <- unlist(defaults)
tab <- tibble::tibble(Method = meth, Description = desc, Arguments = args, Defaults = defaults)

knitr::kable(tab)
```

## Classification

Classification assesses the extent of discrimination between sample classes.
This analysis element utilises the `accest` function from the *[FIEmspro](https://github.com/wilsontom/FIEmspro)* package.
It uses re-sampling based methods where the data are partitioned into training and test sets.
The training set is used to build the intial model based on a specified algorithm which is then used to predict the class labels of the test set.
This allows the assessment of a models accuracy, AUC and margin.
The re-sampling process is repeated numerous times allowing mean aggregation of these classification measures.
These methods use are excuted using binary class comparisons all combinations of comparisons are run separately.

The default parameters for classification are shown below.

```{r classificationParameters}
parameters <- analysisParameters('classification')
parameters
```

These parameters denote the following:

* `cls` - The info column to use for class labels.
* `method` - The classifier to use (`randomForest`, `svm`, `nlda`). More than one can be selected at a time.
* `pars` - Classification parameters to be passed to `valipars` (`?FIEmspro::valipars`).
* `nCores` - The number of cores to use for parallisation.
* `clusterType` - The cluster type to use for parallisation (`?parallel::makeCluster`)

This classification analysis can then be perfomed on the pre-treated data from the previous section.

```{r classificationAnalysis,eval=FALSE}
analysis <- reAnalyse(analysis,parameters)
```

The classification results will then be returned withing the classification slot of the Analysis object as an object of class `accest` (`?FIEmspro::accest`).

## Feature Selection

```{r featureSelectionParameters}
parameters <- analysisParameters('featureSelection')
parameters
```

```{r featureSelectionExample,eval=FALSE}
analysis <- reAnalyse(analysis,parameters)
```

```{r fsMethodsTable,echo=FALSE,results='asis'}
desc <- metabolyseR:::fsMethods(description = T)
args <- lapply(desc,function(x){return(x$arguments)})
args <- lapply(args,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
args <- lapply(args,function(x){apply(x,1,function(y){paste(y,collapse = ' - ')})})
if (T %in% (sapply(args,length) > 1)) {
  args[sapply(args,length) > 1] <- lapply(args[sapply(args,length) > 1],function(x){paste(x,collapse = '; ')})
}
args <- unlist(args)
desc <- unlist(lapply(desc,function(x){return(x$description)}))
meth <- names(metabolyseR:::fsMethods())
defaults <- lapply(metabolyseR:::fsMethods(),formals)
defaults <- lapply(defaults,function(x){x$dat <- NULL;return(x)})
defaults <- lapply(defaults,function(x){tibble::tibble(Parameter = names(x),Value = unlist(x))})
defaults <- lapply(defaults,function(x){apply(x,1,function(y){paste(y,collapse = ' = ')})})
if (T %in% (sapply(defaults,length) > 1)) {
  defaults[sapply(defaults,length) > 1] <- lapply(defaults[sapply(defaults,length) > 1],function(x){paste(x,collapse = '; ')})
}
defaults <- unlist(defaults)
tab <- tibble::tibble(Method = meth, Description = desc, Arguments = args, Defaults = defaults)

knitr::kable(tab)
```

## Correlations

```{r correlationsParameters}
parameters <- analysisParameters('correlations')
parameters
```

```{r correlationsExample,eval=FALSE}
analysis <- reAnalyse(analysis,parameters)
```

## Visualisation and Workflows
