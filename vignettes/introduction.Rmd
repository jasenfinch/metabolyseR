---
title: "metabolyseR"
subtitle: "`r paste0('v',packageVersion('metabolyseR'))`"
author: "Jasen Finch"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  prettydoc::html_pretty:
    toc: true
    highlight: github
    theme: tactile
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r,include=FALSE}
knitr::opts_chunk$set(fig.align = 'center')
library(magrittr)
```

## Introduction

Extracting biological information, related to experimental treatments, from metabolomics data involves a number of steps; data pre-treatment, assessing the extent of discrimination or association between treatment classes and identifying explanatory features responsible for this.
The *metabolyseR* package provides a suite of methods that encompass these aspects of metabolomics data analysis and include the following three analysis elements:

* data pre-treatment
* modelling / data mining
* correlation analyses

The *metabolyseR* package also distinguishes between the flexibility and simplicity required for **exploratory** analyses and the convenience needed for complex **routine** analyses. 
This is reflected in the underlying S4 classes and associated methods defined within the package.
It should be noted that it is useful to understand the principles involved in using *metabolyseR* for exploratory analyses in manipulating and extracting the results generated from routine analyses.

The following document will provide an introduction to the basic usage of the package that includes how to create an manipulate the base classes that are the foundation of *metabolyseR* .
This will be focused around the application for both exploratory and routine analyses.
For more detailed information on the individual analysis elements see their associated vignette using:

```{r vignettes, eval=FALSE}
browseVignettes('metabolyseR')
```

There is also an example quick start analysis vignette provided. 
This can be found using:

```{r example_analysis,eval=FALSE}
vignette('quick_start','metabolyseR')
```

Any issues or bugs found while using the package should be reported [here](https://github.com/jasenfinch/metabolyseR/issues).

The examples shown here will use the `abr1` data set from the *[metaboData](https://github.com/aberHRML/metaboData)* package (`?metaboData::abr1`).
This is a nominal mass flow-injection mass spectrometry (FI-MS) fingerprinting data set from a plant-pathogen infection time course experiment. 
The examples will also include use of the pipe `%>%` from the [magrittr](https://cran.r-project.org/web/packages/magrittr/index.html) package.

Firstly load the relevant packages:

```{r libraryLoad,message=FALSE}
library(metabolyseR)
library(metaboData)
```

## Exploratory analyses

For exploratory analyses, simple questions of the data need to be answered quickly.
This means that key requirements for any tool used by investigators for performing exploratory analyses are both simple and flexible.

In *metabolyseR*, the `AnalysisData` class is the base S4 class that provides these requirements.
This is "requires metabolomics data and sample information, rows observations, columns metabolome features (eg. mass spectral signals)"

The following sections will give an overview of the basics in constructing and manipulating these objects as the base for analysis.

### Analysis data

We can firstly construct an `AnalysisData` object to analyse consisting of two data tables.
The first contains the metabolomic data where the columns are the metabolome features, the rows the sample observations and the values.
The second contains the sample meta-information with the row order matching those of the metabolome data table.
Using the example data, his can be constructed and assigned to the variable `d` by:

```{r analysis_data}
d <- analysisData(data = abr1$neg,
                  info = abr1$fact)
```

Where `abr1$neg` is the negative ionisation mode data and `abr1$fact` is the corresponding sample information.
By printing `d` we can view some basic information about our data.

```{r print_analysis_data}
d
```

We can also return the numbers of samples and numbers of features respectively using the following:

```{r number_samples_features}
nSamples(d)
nFeatures(d)
```

The dat 
```{r dat}
dat(d)
```

```{r new_dat}
dat(d) <- abr1$pos
```

```{r print_analysis_data2}
d
```

```{r sinfo}
sinfo(d)
```

```{r new_sinfo}
sinfo(d) <- abr1$fact[,1:2]
```

```{r print_analysis_data3}
d
```

```{r analysis_data2,echo=FALSE}
d <- analysisData(abr1$neg,abr1$fact)
```

### Sample information

```{r,results='asis',echo=FALSE}
getNamespaceExports('metabolyseR') %>% 
  {.[stringr::str_detect(.,'cls')]} %>% 
  {.[!stringr::str_detect(.,':')]} %>% 
  sort() %>% 
  stringr::str_c('* ',.) %>% 
  stringr::str_c(collapse = '\n') %>%
  cat()
```

```{r}
clsAvailable(d)
```

```{r}
clsExtract(d,cls = 'day')
```
```{r}
clsExtract(d,cls = 'day') %>%
  table()
```

```{r}
d <- clsAdd(d,cls = 'new_class',value = rep(1,nSamples(d)))
clsAvailable(d)
```



### Keeping / removing samples or features

```{r}
head(features(d))
```

```{r}
d %>%
  keepFeatures(features = head(features(d)))
```


## Routine analyses

*metabolyseR* has three main functions for performing analyses:

* `analysisParameters` - allows the selection of analysis parameters.
* `metabolyse` - input data and info to analyse using the selected parameters.
* `reAnalysis` - re-analyse data previously analysed using `metabolyse` based on newly selected parameters.

### Parameters

Parameter selection is the fundamental aspect of using *metabolyseR* and will be the most modified as it dictates how the analyses will be performed.
`analysisParameters` returns an object of class `AnalysisParameters` containing the relevant parameters of the selected analysis elements.
For example, the code below will return default parameters for all the *metabolyseR* analysis elements.

```{r parametersExample,eval=FALSE}
parameters <- analysisParameters()
parameters
```

To retrieve parameters for a subset of elements the following can be run, which will return parameters for only the `preTreat` and `modelling` elements. 

```{r parametersElementSubset}
parameters <- analysisParameters(c('preTreat','modelling'))
parameters
```

These parameters have been named so that a parameters that denote the same functionality will be named commonly across all methods.
The `changeParameter` function can be used to uniformly change these parameters across all of the selected methods.
The example below changes the defaults of all the parameters named `clusterType` from `FORK` to `PSOCK`.

```{r changeParameter,eval=F}
parameters <- analysisParameters()
parameters
parameters <- changeParameter(parameters,'cls','day')
parameters
```

Alternatively the parameters of a specific analysis elements can be targeted using the `elements` argument.
The following will only alter the `cls` parameter for the pre-treatment element:

```{r changeParameterElement,eval=FALSE}
parameters <- changeParameter(parameters,'cls','class',elements = 'preTreat')
```


To change parameters individually, the `@` extraction operator can be used to access the relevant slot directly.
For instance, the following code illustrates how to modify the occupancy threshold parameter for class imputation for data pre-treatment from 2/3 to 1/2.

```{r parametersSetExample,eval=FALSE}
parameters@preTreat$impute$class$occupancy <- 1/2
parameters
```

Discussion of parameters particular to the individual analysis elements can be found in the relevant analysis element sections.

Due to the complex nature of the list structures needed for the analyses containing many components, it is possible to express these parameters more simply in YAML format and parse these into R using `parseParameters()`.
Below shows an example `.yaml` file that would give the same default `AnalysisParameters` object when `analysisParameters()` is called.

```{r defaultYAML,echo=FALSE,results='asis'}
paramFile <- system.file('defaultParameters.yaml',package = 'metabolyseR')

stringr::str_c("
```yaml
",
yaml::read_yaml(paramFile) %>%
  yaml::as.yaml(),
"```") %>%
  cat()
```

This can be passed directly into an `AnalysisParameters` object using the following:

```{r parseParametes,eval=F}
p <- parseParameters(paramFile)
p
```

For more complex pre-treatment situations such as the following:

```{r exampleYAML,echo=FALSE,results='asis'}
exampleParamFile <- system.file('exampleParameters.yaml',package = 'metabolyseR')

stringr::str_c("
```yaml
",
  yaml::read_yaml(exampleParamFile) %>%
    yaml::as.yaml(),
  "```") %>%
  cat()
```

Where multiple remove steps are needed, these are numbered sequentially.
Also where multiple values need to be provided to a particular argument (e.g. `classes = c('H','1')`), these should be supplied as a hyphenated list.

```{r}
p <- parseParameters(exampleParamFile)
p
```

### Analysis

Executing analyses is simple using the `metabolyse` function with specification of the data to use, the sample meta-information (info) and the analysis parameters.
This is shown by the following code.

```{r metabolyseExample}
parameters <- analysisParameters(c('preTreat','modelling'))
parameters@preTreat <- list(
  occupancyFilter = list(maximum = list()),
  transform = list(TICnorm = list())
)
analysis <- metabolyse(abr1$neg,abr1$fact,parameters) 
analysis
```

The data and info can be either `tibble` or `data.frame` structures and the parameters should be an S4 object of class `AnalysisParameters`.
The order of the rows of the info table should agree with those in the data table.

`metabolyse` returns an S4 object of class `Analysis`.
Data and analysis results can be extracted from this object using the following functions:

* `rawData()` - raw data.
* `rawInfo()` - raw info.
* `preTreatedData()` - pre-treated data.
* `preTreatedInfo()` - pre-treated info.
* `modellingResults()` - modelling results.
* `correlationResults()` - correlation results.

If data pre-treatment has not been performed prior to modelling, the raw data will automatically be used.
The date and time of each of analysis of each of the elements is also stored and can is displayed when the object is printed.

### Re-Analysis

There are likely to be occasions where analyses need to be re-analysed using a new set of parameters. 
`reAnalyse` can be used for this.
It simply requires the specification of the `Analysis` object and parameters for the re-analysis as shown below.

```{r reAnalyseExample,eval=FALSE}
parameters <- analysisParameters('correlations')
analysis <- reAnalyse(analysis,parameters)
analysis
```
