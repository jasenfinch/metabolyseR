---
title: "Metabolomics data pre-treatment"
subtitle: "`r paste0('metabolyseR v',packageVersion('metabolyseR'))`"
author: "Jasen Finch"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  prettydoc::html_pretty:
    toc: true
    highlight: github
    theme: tactile
vignette: >
  %\VignetteIndexEntry{Metabolomics data pre-treatment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(knitr)
library(tibble)
library(dplyr)
library(purrr)
library(stringr)

opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  fig.align = 'center'
)
```

## Introduction

Metabolomics data from any analytical technique requires various data pre-treatment steps prior to subsequent data mining or other downstream analyses and aids both data quality and integrity.
It is important that appropriate pre-treatment strategies are used not only for the analytical technique being applied but are also suitable for the statistical or machine learning analyses that are to be utilised.

Data pre-treatment is the most faceted aspect of the analysis elements in *metabolyseR*.
It itself is made up of a number of elements, which themselves are made up of methods.
The following document will outline the application of each of these pre-treatment elements for use in exploratory analyses then outline how to apply them in routine analyses.
For an introduction to the usage of *metabolyseR* for both exploratory and routine analyses, see the introduction vignette using:

```{r introduction_vignette,eval=FALSE}
vignette('introduction','metabolyseR')
```

To further supplement this document, a quick start example analysis is also available as a vignette:

```{r example_analysis,eval=FALSE}
vignette('quick_start','metabolyseR')
```

To begin, the package can be loaded using:

```{r package_load}
library(metabolyseR)
```

### Example data

The examples used here will use the `abr1` data set from the [metaboData](https://github.com/aberHRML/metaboData) package. 
This is nominal mass flow-injection mass spectrometry (FI-MS) fingerprinting data from a plant-pathogen infection time course experiment.
The pipe `%>%` from the [magrittr](https://cran.r-project.org/web/packages/magrittr/index.html) package will also be used.
The example data can be loaded using:

```{r data_load}
library(metaboData)
```

Only the negative acquisition mode data (`abr1$neg`) will be used along with the sample meta-information (`abr1$fact`).
Create an `AnalysisData` class object, assigned to the variable `d`, using the following:

```{r example_data}
d <- analysisData(abr1$neg,abr1$fact)
```

```{r print_data}
print(d)
```

As can be seen above the data set contains a total of `r nSamples(d)` samples and `r nFeatures(d)` features.

## Pre-treatment elements

### Sample and feature removal

The removal of samples prior to their analysis is important if there are outlier samples included or sample classes that are no longer relevant for the intended analyses.

```{r remove_samples}
d %>%
  removeSamples(idx = 'injorder',samples = 1)
```

```{r remove_classes}
d %>%
  removeClasses(cls = 'day',classes = 'H')
```

```{r}
d %>%
  features() %>%
  head()
```

```{r remove_features}
d %>%
  removeFeatures(features = c('N1','N2'))
```

Variable removal is important if for example there is contaminant features present in a data set. 


The methods and their arguments for the removal of samples is shown in the table below.

### Keep samples and features

The opposite of the remove methods discussed above. 
Useful if there are fewer samples, classes or variables to keep than to remove.

```{r keep_samples}
d %>%
  keepSamples(idx = 'injorder',samples = 1)
```

```{r keep_classes}
d %>%
  keepClasses(cls = 'day',classes = 'H')
```

```{r keep_features}
d %>%
  keepFeatures(features = c('N1','N2'))
```

The methods and their arguments for keeping samples is shown in the table below.

### Variable filtering based on occupancy

Occupancy provides a useful measure by which to filter variables that are poorly represented (contain a majority of missing values).
An occupancy threshold provides a means of specifying this majority with variables below the threshold excluded from further analyses.
However, this can be complicated by an underlying class structure present within the data where a variable may be well represented within one class but not in another.

An occupancy threshold can be applied both minimally and maximally within the class structure.
A minimally applied threshold would require all the classes to have an occupancy above the threshold for the variable to be retained.
A maximally applied threshold would require only a single class to have an occupancy above the threshold for the variable to be retained.
The later strategy has the important benefit of retaining any presence and absence trends that may be present.

```{r occupancy}
d %>%
  occupancy()
```

```{r plot_occupancy}
d %>%
  plotOccupancy(cls = 'day')
```

```{r filter_occupancy}
filtered_occupancy <- d %>%
   occupancyMaximum(cls = 'day',occupancy = 2/3)
```

```{r print_filtered_occupancy}
print(filtered_occupancy)
```

```{r plot_filtered_occupancy}
filtered_occupancy %>%
  plotOccupancy(cls = 'day')
```

The methods and their arguments for occupancy based variable filtering are shown in the table below.

### Batch/block correction

There can sometimes be artificial batch related variability introduced introduced into metabolomics analyses as a result of analytical instrumentation or sample preparation.
With appropriate sample randomisation (see section Variable filtering based on QC samples) batch related variability can be corrected for using the methods shown in the table below.

```{r day_TICs}
d %>%
  plotTIC(by = 'day',colour = 'day')
```

```{r correction}
d %>%
  correctionCenter(block = 'day',type = 'median',nCores = 2) %>%
  plotTIC(by = 'day',colour = 'day')
```

### Sample aggregation

Sample aggregation allows the electronic pooling of samples based on a grouping variable.
This is useful in situations such as the presence of technical replicates that can be aggregated to reduce the effects of pseudo replication.

```{r pca}
d %>%
  occupancyMaximum(cls = 'day') %>%
  plotPCA(cls = 'day')
```

```{r day_mean}
day_mean <- d %>%
  occupancyMaximum(cls = 'day') %>%
  aggregateMean(cls = 'day')
```

```{r day_mean_pca}
plotPCA(day_mean,cls = 'day',ellipses = FALSE)
```



The methods and their arguments are shown in the table below.

### Imputation of missing data

Missing values can have an important influence on downstream analyses with zero values heavily influencing the outcomes of parametric tests.
Where and how they are imputed are important considerations and is highly related to variable occupancy.
Imputation accuracy is likely to be reduced if data is sparse or there is underlying class structure where there is significant discrimination.

```{r lda}
d %>%
  occupancyMaximum(cls = 'day',occupancy = 2/3) %>%
  plotLDA(cls = 'day')
```

```{r imputed_lda}
d %>%
  occupancyMaximum(cls = 'day',occupancy = 2/3) %>%
  imputeClass(cls = 'day',nCores = 2) %>%
  plotLDA(cls = 'day')
```

The methods provided here allow both these aspects to be taken into account and utilise Random Forest imputation using the [*missForest*]( https://CRAN.R-project.org/package=missForest) package.
Their arguments are shown in the table below.

### Data transformation

Prior to downstream analyses, metabolomics data often require a transformation step to allow the data to meet the assumptions of a particular statistical inference or account for potential variability in sample concentration.

There are a wide range of transformation methods available that are commonly used for the analysis of metabolomics data.
The methods and their arguments are shown in the table below.


```{r occupancy_filter_transform}
occupancy_filtered <- d %>%
  occupancyMaximum(cls = 'day',occupancy = 2/3)
```

```{r transform_RF}
occupancy_filtered %>%
  plotSupervisedRF(cls = 'day')
```

```{r log10_RF}
occupancy_filtered %>%
  transformLog10() %>%
  plotSupervisedRF(cls = 'day')
```

```{r TICnorm_RF}
occupancy_filtered %>%
  transformTICnorm() %>%
  plotSupervisedRF(cls = 'day')
```

### Variable filtering based on quality control (QC) samples

A QC sample is an average pooled sample, equally representative in composition of all the samples present within an experimental set.
Within an analytical run, the QC sample is analysed intermittently at equal intervals throughout the run.
If there is class structure within the run this should be randomised within a block fashion so that the classes are equally represented in each block throughout the run.
QC samples can then be injected between these randomised blocks.
This provides a set of technical injections that allows the variability in instrument performance over the run to be accounted for and the robustness of the acquired variables to be assessed.

The technical reproducibility of an acquired variable can be assessed using it's relative standard deviation (RSD) within the QC samples.
The variable RSDs can then be thresholded to filter out variables that are poorly reproducible across the analytical runs.
This variable filtering strategy has an advantage over that of occupancy alone as it is not dependent on underlying class structure.
Therefore the variables and variable numbers will not alter if a new class structure is imposed upon the data.

The methods and arguments for variable filtering based upon QC samples are shown in the table below.

```{r QC_data}
QC <- d %>%
  keepClasses(cls = 'day',classes = 'H')
```

```{r QC_rsd}
QC %>%
  rsd(cls = 'day')
```


```{r QC_rsd_plot}
QC %>%
  plotRSD(cls = 'day')
```
```{r QC_occupancy_rsd}
QC %>%
  occupancyMaximum(cls = 'day',occupancy = 2/3) %>%
  plotRSD(cls = 'day')
```

```{r QC_filtered}
QC_filtered <- d %>%
  QCoccupancy(cls = 'day',QCidx = 'H',occupancy = 2/3) %>%
  QCrsdFilter(cls = 'day',QCidx = 'H',RSDthresh = 0.5)
```

```{r print_QC_filtered}
print(QC_filtered)
```

## Routine analyses

The pre-treatment elements can be seen below.

```{r pre-treatment_elements}
preTreatmentElements()
```

```{r pre-treatment_methods}
preTreatmentMethods('remove')
```

The parameter selection for the pre-treatment elements will firstly be discussed, with more in-depth discussion on the methods of the individual elements to follow. 

### Parameter Selection

The default pre-treatment parameters can be seen below.

```{r preTreatDefaults}
analysisParameters('pre-treatment')
```

This pre-treatment analysis is made up of three elements that include variable filtering based on QC samples, missing data imputation and data transformation (`QC`, `impute` and `transform` respectively).
Each of these elements is made up of varying numbers of methods, with each method having its own arguments.
The order in which these elements and their methods is displayed is the order in which their execution upon the data will take place.
This allows the fine specification of the data pre-treatment routines that are required for the particular data.

Pre-treatment routines can be customised by altering the `preTreat` slot within the `AnalysisParameters` object as shown below.

```{r preTreatParameterExample}
p <- analysisParameters('pre-treatment')
```

```{r}
parameters(p,'pre-treatment') <- preTreatmentParameters(
  list(
    keep = 'classes',
    occupancyFilter = 'maximum',
    transform = 'TICnorm' 
  )
)
```

```{r}
changeParameter(p,'cls') <- 'day'
changeParameter(p,'classes') <- c('H','1','2')
```

```{r}
p
```

This routine will firstly remove a number of classes, filter the variables based on class occupancy and then transform the data using a total ion count normalisation.

The pre-treatment routines are specified as a hierarchy of lists within lists.
Firstly the pre-treatment elements should be specified within a list with the particular element methods specified as lists within these.
The method arguments are then declared within these lists.
Empty lists for methods can be specified to use the default arguments; however, element lists should not be empty. 

The pre-treatment routine can then be executed using the following.

```{r preTreatExample}
analysis <- metabolyse(abr1$neg,abr1$fact,p)
```

```{r}
analysis
```

```{r}
analysis %>%
  plotSupervisedRF(cls = 'day')
```

### Method reference table

```{r method_reference_table,echo=FALSE}
metabolyseR:::preTreatmentElements() %>%
  map(~{
    methods <- metabolyseR:::preTreatmentMethods(.x)
    element_methods <- metabolyseR:::getPreTreatMethods(.x)
    methods %>%
      map(~{
        element_methods(.x,description = TRUE) %>%
          {
            tibble(Description = .$description,
                   Arguments = .$arguments %>%
                     {
                       str_c(names(.),.,sep = ' - ')
                     } %>%
                     str_c(collapse = '; '),
                   Defaults = .x %>%
                     element_methods() %>%
                     formals() %>%
                     {
                       . <- .[-1]
                       return(.)
                     } %>%
                     {
                       str_c(names(.),unlist(.,use.names = FALSE),sep = ' = ')
                     } %>%
                     str_c(collapse = '; ')
            )
          }
      }) %>%
      set_names(methods) %>%
      bind_rows(.id = 'Method')
  }) %>%
  set_names(preTreatmentElements()) %>%
  bind_rows(.id = 'Element') %>%
  kable()
```

